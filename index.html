<!DOCTYPE html>
<html>
    <head>
        <title>as-graph</title>
        <link rel="stylesheet" href="css/styles.css">
        <script src="js/viz.js"></script>
        <script src="js/full.render.js"></script>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1 class="title">as-graph</h1>
                <span class="smalltitle">
                    Simple BGP route propagation debugger.
                </span>
            </div>
            
            <div class="box controlboxes">
                <div class="controlbox">
                    <label for="query">Show route propagation by IP, prefix, or ASN:</label>
                    <div class="control">
                        <input type="text" id="query" autocomplete="off" spellcheck="false" placeholder="ASN, IP or prefix...">
                        <input type="checkbox" id="showleaf">
                        <label for="showleaf">show all leaf nodes</label>
                        <button class="button" id="querybtn">Go</a>
                    </div>
                </div>
            </div>
            <div class="box log">
                <pre class="log_out" id="log">
                </pre>
            </div>
            <div class="box display" id="display">
            </div>
        </div>
    </body>
    <script>
        var element;
        var display = document.getElementById('display');
        var log = document.getElementById('log');

        var querybtn = document.getElementById('querybtn');
        var query = document.getElementById('query');

        var showleaf = document.getElementById('showleaf');

        query.addEventListener('keyup', e => { if (e.key === "Enter") { querybtn.click(); } } );

        var disable = () => {
            window.onhashchange = undefined;
            [querybtn, query].forEach(e => e.disabled = true);
        };
        var enable = () => {
            window.onhashchange = () => doQuery();
            [querybtn, query].forEach(e => e.disabled = false);
        };

        var m_log = function(msg) {
            console.log(msg);
            log.innerText = `[INFO ] ${msg}\n` + log.innerText;
        }

        var m_err = function(msg) {
            console.error(msg);
            log.innerText = `[ERROR] ${msg}\n` + log.innerText;
        }

        var render = async function (graph) {
            m_log('render: request render...');
            var viz = new Viz();
            if (element) element.remove();
            try {
                element = await viz.renderSVGElement(graph);
                display.appendChild(element);
                m_log('render: done.');

            } catch(err) {
                m_err(err);
            }
        };

        var ripeGet = function (apiUrl) {
            return new Promise((resolve, reject) => {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', `https://stat.ripe.net/data/${apiUrl}`);
                xhr.send();
                xhr.onload = function () {
                    if (this.status == 200) {
                        res = JSON.parse(xhr.response);
                        if (res.status === 'ok') resolve(res.data);
                        else reject('API: RIPE API returned not-OK.');
                    } else reject('API: got non-200 response.');
                };
            });
        }

        var renderByPrefixesOrAddresses = async function (poas) {
            var links = new Set();

            await Promise.all(poas.map(async poa => {
                try {
                    m_log(`getGraphByPrefixesOrAddresses: constructing graph with prefix/IP "${poa}"...`);

                    var rslt = await ripeGet(`looking-glass/data.json?resource=${poa}`);
                    var paths = rslt.rrcs.map(rrc => rrc.peers).flat().map(peer => peer.as_path.split(' '));

                    paths.forEach(path => {
                        var last;

                        path.forEach((asn, i, a) => {
                            if (last && last != asn && (a.length <= 2 || i > 1 || showleaf.checked)) {
                                links.add(`AS${asn} [URL="https://bgp.he.net/AS${asn}"]`);
                                links.add(`AS${last} [URL="https://bgp.he.net/AS${last}"]`);
                                links.add(`AS${asn}->AS${last}`);
                            }
                            last = asn;
                        });
                    });

                    m_log(`getGraphByPrefixesOrAddresses: done: "${poa}".`)
                } catch (e) {
                    m_err(e);
                }
            }));

            var graph = `digraph{rankdir="LR";${Array.from(links).join(';')}}`;
            console.log(graph);
            render(graph);
        };

        var renderByAs = async function (as) {
            var format_ok = false;

            as = as.toUpperCase();

            if(/^[1-9]+[0-9]*/.test(as)) {
                as = `AS${as}`;
                format_ok = true;
            }
            if (/^AS[1-9]+[0-9]*/.test(as)) format_ok = true;
            if (!format_ok) {
                throw 'getPrefixesByAs: bad ASN.';
            }

            m_log(`getPrefixesByAs: getting prefixes list for ${as}...`);

            var rslt = await ripeGet(`announced-prefixes/data.json?resource=${as}`);
            var prefixes = rslt.prefixes.map(p => p.prefix);

            m_log(`getPrefixesByAs: done, found ${prefixes.length} prefix(es).`);

            if (prefixes.length > 200) {
                if (!confirm(`${as} has a large number of routes (${prefixes.length}), are you sure you want to proceed? Continuing may cause your browser to hang.`)) {
                    m_log('getPrefixesByAs: aborted.');
                    return;
                }
            }

            renderByPrefixesOrAddresses(prefixes);
        };

        var doQuery = (target) => {
            disable();
            if (target) {
                window.location.hash = `${target}`;
            }
            try {
                var hash = window.location.hash.replace('#', '').toUpperCase();
                if (hash != "") {
                    query.value = hash;
                    if (/^AS[1-9]+[0-9]*$/.test(hash)) renderByAs(hash);
                    else if (/^[1-9]+[0-9]*$/.test(hash)) renderByAs(`AS${hash}`);
                    else renderByPrefixesOrAddresses([hash]);
                }
            } catch (err) {
                m_err(err);
            }
            enable();
        };

        querybtn.onclick = () => {
            doQuery(query.value)
        };

        window.onhashchange = () => doQuery();
        document.body.onload = () => doQuery();
    </script>
</html>